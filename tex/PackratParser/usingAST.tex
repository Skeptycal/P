% Copyright (c) 2012, Andrew Carter, Dietrich Lagenbach, Xanda Schofield
% All rights reserved.
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
% 1. Redistributions of source code must retain the above copyright notice, this
%    list of conditions and the following disclaimer.
% 2. Redistributions in binary form must reproduce the above copyright notice,
%    this list of conditions and the following disclaimer in the documentation
%    and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
% ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
% WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
% DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
% ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
% (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
% LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
% ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
% (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
% SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
% The views and conclusions contained in the software and documentation are those
% of the authors and should not be interpreted as representing official policies,
% either expressed or implied, of the FreeBSD Project.
\section{Abstract Syntax Trees}
The Abstract Syntax Tree class (\AST) represents the syntax tree generated by a \grammar\ on an input.
    The tree contains either name or indexed based child nodes, or the string that it parses if it is a leaf node.
    The tree also keeps track of where in the string it starts, to where it end.
    There are two sets of methods, one for creating and modifying abstract syntax trees, and another for reading them.

\section{Creating and Modifying Abstract Syntax Trees}

\subsection{Creation via a \Grammar}
This is the normal way of creating an \AST.

\section{Reading an Abstract Syntax Tree}
While it is possible to extract information about the structure of the \AST\ 
    by determining if certain named children exist or checking whether a node contains a string,
    it is recommended that any \grammar\ should use named constants to help the reader to determine the structure.
    For convienence, an \AST\ that does not match anything, when tested as a bool is \code{false}.

An \AST\ can be like a pointer in one of the following ways
    \begin{enumerate}
        \item A direct pointer to a string.
        \item A pointer to a numeric array of children.
        \item A pointer to a named array (hashmap) of children.
    \end{enumerate}
    one again it is possible to determine what type of pointer an \AST\ is,
    but it is recommended that the \grammar\ can only generate one type of pointer at any level.

\subsection{Reading a Leaf}
A \AST\ that is a pointer to the string can be accessed via the unary \code{*} operator.
    For example if a AST represents an integer value, the following funtion will retrieve it:
    \begin{verbatim}
    int ASTtoInt(const AST& ast)
    {
        int i;
        istringstream(*ast) >> i;
        return i;
    }
    \end{verbatim}
    would take in an \AST\ and return a string.

An \AST\ is only a leaf if it has no children.
    If any children exist, then the string it returns will be the empty string (\code{""}).

\subsection{Reading a numeric array}
An \AST\ that is a pointer to a numeric array of children can be accessed via the (\code{[]}) operator,
    with a \code{size\_t} as the index.
    Thus for \code{AST ast}, \code{ast[i]} will return the $i^{th}$ match in a particular \code{*} or \code{+} packrat repetition.
    The total number of matches may be accessed by the \code{length()} method.

Alternatively the \AST\ class also permits iterators, with the \code{begin()} and \code{end()} methods.

For example if an \AST\ represented a list of children of integers that need to be summed,
    the following code may be used:
    \begin{verbatim}
    int sumAST1(const AST& ast)
    {
        int sum = 0;
        for(int i = 0; i < ast.length(); ++i)
            sum += ASTtoInt(ast[i]);
        return sum;
    }
    
    int sumAST1(const AST& ast)
    {
        int sum = 0;
        for(AST::const_iterator i = ast.begin(); i != ast.end(); ++i)
            sum += ASTtoInt(*i);
        return sum;
    }
    \end{verbatim}

If an \AST\ is indexed into, and the \AST\ does not contain that many elements,
    then the \AST\ is extended if it is not a \code{const AST} with non-matching \AST\,
    and the last one is returned.
    If it is a \code{const AST}, then a non-matching \AST\ is returned.

\subsection{Reading a named array}
An \AST\ that is a pointer to a named array of children can be accessed via the (\code{[]}) operator,
    with a \code{string} as the index.
    For instance, if a \AST\ has a type and a value, with one option for the type being the constant \code{"SUM"},
    and in which case you want to sum the value, which is a list of numbers, then the following code could be used:
    \begin{verbatim}
    int eval(const AST& ast)
    {
        if(*ast["type"] == "SUM")
            return sumAST(ast["value"])
        ...
    }
    \end{verbatim}

If an \AST\ is indexed with a \code{string} that does not refernce any \AST,
    then if the \AST\ is not a \code{const AST} a new non-matching \AST is created and put in that index.
    Otherwise a non-matching \AST\ is returned.
