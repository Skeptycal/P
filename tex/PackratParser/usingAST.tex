\section{Abstract Syntax Trees}
The Abstract Syntax Tree class (\AST) represents the syntax tree generated by a \grammar\ on an input.
    The tree contains either name or indexed based child nodes, or the string that it parses if it is a leaf node.
    The tree also keeps track of where in the string it starts, to where it end.
    There are two sets of methods, one for creating and modifying abstract syntax trees, and another for reading them.

\section{Creating and Modifying Abstract Syntax Trees}

\subsection{Creation via a \Grammar}
This is the normal way of creating an \AST.

\section{Reading an Abstract Syntax Tree}
While it is possible to extract information about the structure of the \AST\ 
    by determining if certain named children exist or checking whether a node contains a string,
    it is recommended that any \grammar\ should use named constants to help the reader to determine the structure.
    For convienence, an \AST\ that does not match anything, when tested as a bool is \code{false}.

An \AST\ can be like a pointer in one of the following ways
    \begin{enumerate}
        \item A direct pointer to a string.
        \item A pointer to a numeric array of children.
        \item A pointer to a named array (hashmap) of children.
    \end{enumerate}
    one again it is possible to determine what type of pointer an \AST\ is,
    but it is recommended that the \grammar\ can only generate one type of pointer at any level.

\subsection{Reading a Leaf}
A \AST\ that is a pointer to the string can be accessed via the unary \code{*} operator.
    For example if a AST represents an integer value, the following funtion will retrieve it:
    \begin{verbatim}
    int ASTtoInt(const AST& ast)
    {
        int i;
        istringstream(*ast) >> i;
        return i;
    }
    \end{verbatim}
    would take in an \AST\ and return a string.

An \AST\ is only a leaf if it has no children.
    If any children exist, then the string it returns will be the empty string (\code{""}).

\subsection{Reading a numeric array}
An \AST\ that is a pointer to a numeric array of children can be accessed via the (\code{[]}) operator,
    with a \code{size\_t} as the index.
    Thus for \code{AST ast}, \code{ast[i]} will return the $i^{th}$ match in a particular \code{*} or \code{+} packrat repetition.
    The total number of matches may be accessed by the \code{length()} method.

Alternatively the \AST\ class also permits iterators, with the \code{begin()} and \code{end()} methods.

For example if an \AST\ represented a list of children of integers that need to be summed,
    the following code may be used:
    \begin{verbatim}
    int sumAST1(const AST& ast)
    {
        int sum = 0;
        for(int i = 0; i < ast.length(); ++i)
            sum += ASTtoInt(ast[i]);
        return sum;
    }
    
    int sumAST1(const AST& ast)
    {
        int sum = 0;
        for(AST::const_iterator i = ast.begin(); i != ast.end(); ++i)
            sum += ASTtoInt(*i);
        return sum;
    }
    \end{verbatim}

If an \AST\ is called, and the \AST\ does not contain that many elements,
    then the \AST\ is extended if it is not a \code{const AST} with non-matching \AST\,
    and the last one is returned.
    If it is a \code{const AST}, then a non-matching \AST\ is returned.

\subsection{Reading a named array}
